<!DOCTYPE html>
<html lang="en-GB">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Ping</title>
	<link rel="icon" href="/favicon.png" type="image/png">
	<style>
		html {
			width: 100%;
			height: 100vh;
		}

		body {
			box-sizing: border-box;
			width: 100%;
			height: 100%;
			margin: 0;
			padding: 1rem;
			background-color: black;
			display: flex;
			flex-direction: column;
			justify-content: center;
		}

		#canvasContainer {
			position: relative;
			width: 100%;
			height: 100%;
		}

		canvas {
			position: absolute;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
			border: 1px solid white;
			cursor: none;
		}
	</style>
</head>
<body>
	<div id="canvasContainer">
		<canvas id="game" width="2" height="1">
			Sorry, your browser is not compatible with this game.
		</canvas>
	</div>
	<script>

		const canvasContainer = document.querySelector('#canvasContainer');
		const canvas = canvasContainer.querySelector('#game');
		const ctx = canvas.getContext('2d');
		const canvasScale = 1000;
		const canvasRatio = 2;
		const canvasWidth = canvasScale * canvasRatio;
		const canvasHeight = canvasScale;
		let offsetX;
		let offsetY;


		const Net = {
			draw: function draw() {
				ctx.save();
				ctx.beginPath();
				ctx.lineWidth = 5;

				const lineLength = canvasHeight / 50;
				const gapLength = lineLength;
				const x = canvasWidth * 0.5;
				let y = lineLength / 2;

				function createNet() {
					ctx.moveTo(x, y);
					y += lineLength;
					ctx.lineTo(x, y);
					y += gapLength;
				}
				while(y < canvasHeight) {
					createNet();
				}
				ctx.stroke();
				ctx.restore();
			}
		}
		const net = Object.create(Net);


		const Paddle = {
			init: function init(side) {
				this.side = side;
				this.w = 25;
				this.h = 200;
				this.y = (canvasHeight - this.h) / 2;
				const baseX = 25;
				if(this.side === 'left') {
					this.x = baseX;
					this.dy = +1;
					this.speed = 10;
					this.move();
				}
				else if(this.side === 'right') {
					this.x = canvasWidth - baseX - this.w;
					canvas.addEventListener('mousemove', this.move.bind(this));
				}
			},

			draw: function draw() {
				ctx.fillRect(this.x, this.y, this.w, this.h);
			},

			move: function move(event) {
				// Player controlled paddle
				if(this.side === 'right') {
					const mouse = (event.y - offsetY);
					const pixel = canvasScale / canvas.clientHeight;
					const offset = this.h / 2;
					let newPosition = (mouse * pixel) - offset;

					if(newPosition < 0) {
						newPosition = 0;
					}
					else if (newPosition > canvasScale - this.h) {
						newPosition = canvasScale - this.h;
					}

					if(newPosition !== this.y) {
						this.y = newPosition;
						refresh();
					}
				}
				// AI controlled paddle
				else {
					this.y += this.dy * this.speed;
					if(this.y < 0) {
						this.y = 0;
						this.dy *= -1;
					}
					else if (this.y + this.h > canvasScale) {
						this.y = canvasScale - this.h;
						this.dy *= -1;
					}
					refresh();
					requestAnimationFrame(this.move.bind(this));
				}
			}
		}
		const p1 = Object.create(Paddle);
		p1.init('left');
		const p2 = Object.create(Paddle);
		p2.init('right');


		const Ball = {
			init: function init() {
				this.h = 50;
				this.w = 50;
				this.x = (canvasWidth / 2) - (this.w / 2);
				this.y = (canvasHeight / 2) - (this.h / 2);
				// 0.67 = 45Â° so ball always goes directly towards paddles
				const dx = Math.random() * (1 - 0.67) + 0.67;
				const dy = 1 - dx;
				function randomDirection() {
					return Math.round(Math.random()) ? 1 : -1;
				}
				this.dx = dx * randomDirection();
				this.dy = dy * randomDirection();
				this.speed = 20;
				this.move();
			},

			draw: function draw() {
				ctx.fillRect(this.x, this.y, this.w, this.h);
			},

			move: function move() {
				this.x += this.dx * this.speed;
				this.y += this.dy * this.speed;

				// top wall collision
				if(this.y < 0) {
					this.y = 0;
					this.dy *= -1;
				}
				// bottom wall collision
				else if(this.y > canvasHeight - this.h) {
					this.y = canvasHeight - this.h;
					this.dy *= -1;
				}

				// paddle collision
				const leftPaddleCollides =
					this.x < p1.x + p1.w &&
					this.y + this.h > p1.y &&
					this.y < p1.y + p1.h
				;
				const rightPaddleCollides =
					this.x + this.w > p2.x &&
					this.y + this.h > p2.y &&
					this.y < p2.y + p2.h
				;
				if(leftPaddleCollides) {
					this.x = p1.x + p1.w;
					this.dx *= -1;
				}
				else if(rightPaddleCollides) {
					this.x = p2.x - this.w;
					this.dx *= -1;
				}

				// point scored
				if(this.x < 0) {
					// TEMPORARY - need to update score and reset here
					this.x = 0;
					this.dx = this.dx * -1;
				}
				else if(this.x > canvasWidth - this.w) {
					// TEMPORARY - need to update score and reset here
					this.x = canvasWidth - this.w;
					this.dx = this.dx * -1;
				}
				refresh();
				requestAnimationFrame(this.move.bind(this));
			}
		}
		const ball = Object.create(Ball);
		ball.init();


		function resizeCanvas(ctx, canvas) {
			const sizes = canvasContainer.getBoundingClientRect();

			if(sizes.width / canvasRatio <= sizes.height) {
				canvas.width = sizes.width;
				canvas.height = sizes.width / canvasRatio;
			}
			else {
				canvas.width = sizes.height * canvasRatio;
				canvas.height = sizes.height;
			}

			const scaleX = canvas.width / canvasScale / canvasRatio;
			const scaleY = canvas.height / canvasScale;
			ctx.scale(scaleX, scaleY);
			ctx.strokeStyle = 'white';
			ctx.fillStyle = 'white';

			offsetX = (window.innerWidth - canvas.clientWidth) / 2;
			offsetY = (window.innerHeight - canvas.clientHeight) / 2;
		}

		function refresh() {
			requestAnimationFrame(function() {
				ctx.clearRect(0, 0, canvasWidth, canvasHeight);
				net.draw();
				p1.draw();
				p2.draw();
				ball.draw();
			})
		}

		window.addEventListener('resize', function() {
			resizeCanvas(ctx, canvas);
			refresh();
		})
		resizeCanvas(ctx, canvas);
		refresh();
	</script>
</body>
</html>